class game
	renderer
	region




region
	struct chunkProtoGeometry


renderer
	renderer_global_state;

	struct chunkBufferGeometry
	
	chunkBufferGeometry createChunkBufferGeometry(chunkProtoGeometry)



	void enable (%BufferGeometry)

	void draw   ()

	void disable(%BufferGeometry)





%ProtoGeometry 	contain gpu-ready geometry in primitive arrays on RAM
%BufferGeometry contain IDs for buffers on Video RAM


# RENDERER DOCUMENTATION

## public variables

## private variables

`int state`
...

## public methods

`int initRenderer()`
...

`%BufferGeometry createBufferGeometry( %ProtoGeometry )`
Uploads geometry in ProtoGeometry to the GPU, and stores their ids in a new BufferGeometry.

`void enable( typeof %BufferGeometry )`
This prepares OpenGL to render provided type of geometry
State must be null

`void render( %BufferGeometry )`
Renders whatever was enabled
State must be set

`void params( %BufferGeometry, ... )`
Used to set parameters like matrices or other uniforms

`void disable( typeof %BufferGeometry )`
Reverts the state to null.
State must be set to the provided buffer type.





## private methods

















### ENTITY SYSTEM



### TERRAIN 

Decide on chunk count. Now, (Chunk *)malloc them. All of them will be used, always.

	typedef struct {
		unsigned short root;
		short flags;
		short loc[3];


	} Chunk;

where flags

	typedef enum {
		READY   	= 1 << 0	// True if mesh is render-ready
		SKIP		= 1 << 1	// True if mesh is only air.
		OUTDATED	= 1 << 2	// True if represented terrain has changed and needs meshing.
		WORKED_ON 	= 1 << 3	// True if a mesher has been put to workÂ§	
	}



Looping done so:

loop all chunks
	if mesh is ready
		render
	loop all mesher threads
		if mesher is idle && mesher has geometry
			upload mesh to gpu, set correct flags for corresponding chunk object
	if mesh is outdated
		loop all mesher threads
			if thread is idle
				forward operation to the mesher
				break loop




^ that up there is the idea

what we do:

loop all chunks
	if mesh is ready
		render
	else
		mesh it, NOW








GREEDY

chunk root is 64

we need 64 masks for each dimension, 64*3

use culled mesher to fill those masks

item in the mask contains all data of the quad

0 is air

32bits=4bytes

[FLAG, COLOR, COLOR, COLOR, COLOR]
color = 3x float 32

{
	{
		2bit vert0_ao
		2bit vert1_ao
		2bit vert2_ao
		2bit vert3_ao
	},
	{
		1bit facing
		1bit mirror
		6bit color
	}
}

AOAOAOAOFMRRGGBB

1 item is 2 bytes.

1 mask is 64*64
											  262144
	readMask( maskBuffer*, root, dimension, slice, item ){
		items = root*root
		slices = root
		return maskBuffer[ (items*slices) * dimension + (items * slice) + item ]
	}
	writeMask( maskBuffer*, root, dimension, slice, item, char){
		items = root*root
		slices = root
		maskBuffer[ (items*slices) * dimension + (items * slice) + item ] = data;
	}

	maskIndex( root, dimension, slice){
		items = root*root
		slices = root
		return (items*slices) * dimension + (items * slice)
	}

		
MASK[ DIMENSION ][ SLICE ][ ITEM ]
		  3			64	    64^2


function encodeMaskItem(facing, inverse, color6bit, ao){
	let value = 0;

	value = color6bit & 0b00111111;
	value = value | (inverse << 6);
	value = value | (facing  << 7);

	for (let i = 0; i < 4; ++i) {
		value = value | ( ao[i] << 8 + i*2 );
	}
	return value;
}

function decodeMaskItem(value){
	let color6bit = value & 0b00111111;
	let inverse = value >> 6 & 0b1;
	let facing  = value >> 7 & 0b1;
	let ao = [];
	for (let i = 0; i < 4; ++i) {
		ao[i] = (value >> 8 + (i*2)) & 0b11;
	}
	console.log(
		facing,
		inverse,
		color6bit.toString(2),
		ao
	);
}


STORING STUFF IN MASKS

there are 64 slices per dim

current_location[dim] is the slice!!!


slice u v
 [x] [y] [z]
 [y] [x] [z]
 [z] [x] [y]



	int maskIndex( int root, int dimension, int slice){
		int items = root*root;
		int slices = root;
		
		return (items*slices) * dimension + (items * slice);
	}



<!-- MEMORY MANAGER, 6.9.2017 -->


void * createBlock( unsigned int size );

createPartitionTable( void* blockPtr, unsigned int maxPartitions);
/*
	Writes a table to the block
	[ uint, memsize ] [ uint, partcount ]
	[ uint, pointer ] [ uint, size  ]
	[ uint, pointer ] [ uint, size  ]
	...

	first integer is the size of the whole block
	second integer is the count of partitions
	after this the table begins

	each element of the table has 2 values, pointer and a size

	if pointer is NULL (0), theres no partition
	pointers are an offset from the first value of the whole block


*/

int partCount(void* block){
	return block[1];
}

int partTableSize(
){
	
}

alloc( void* block, size ) {
	
	

}